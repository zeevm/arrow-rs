searchState.loadedDescShard("arrow_ord", 0, "Arrow ordering kernels\nComparison kernels for <code>Array</code>s.\nContains functions and function factories to compare …\nDefines partition kernel for <code>ArrayRef</code>\nProvides <code>rank</code> function to assign a rank to each value in …\nDefines sort kernel for <code>ArrayRef</code>\nPerform a potentially vectored <code>op</code> on the provided <code>ArrayOrd</code>\nApplies <code>op</code> to possibly scalar <code>ArrayOrd</code>\nApplies <code>op</code> to possibly scalar <code>ArrayOrd</code> with the given …\nInvokes <code>f</code> with values <code>0..len</code> collecting the boolean …\nCompares two <code>GenericByteViewArray</code> at index <code>left_idx</code> and …\nComparing two <code>GenericByteViewArray</code> at index <code>left_idx</code> and …\nPerform <code>op</code> on the provided <code>Datum</code>\nPerform <code>left IS DISTINCT FROM right</code> operation on two <code>Datum</code>\nPerform <code>left == right</code> operation on two <code>Datum</code>.\nReturns the argument unchanged.\nPerform <code>left &gt; right</code> operation on two <code>Datum</code>.\nPerform <code>left &gt;= right</code> operation on two <code>Datum</code>.\nCalls <code>U::from(self)</code>.\nPerform <code>left &lt; right</code> operation on two <code>Datum</code>.\nPerform <code>left &lt;= right</code> operation on two <code>Datum</code>.\nPerform <code>left != right</code> operation on two <code>Datum</code>.\nPerform <code>left IS NOT DISTINCT FROM right</code> operation on two …\nPerform a take operation on <code>buffer</code> with the given …\nSafety\nCompare the values at two arbitrary indices in two arrays.\nIf parent sort order is descending we need to invert the …\nReturns a comparison function that compares two values at …\nA computed set of partitions, see <code>partition</code>\nReturns a mask with bits set whenever the value or …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns true if this contains no partitions\nReturns the number of partitions\nUse <code>partition</code> instead. Given a list of already sorted …\nGiven a list of lexicographically sorted columns, computes …\nReturns the range of each partition\nAssigns a rank to each value in <code>array</code> based on its …\nA lexicographical comparator that wraps given array data …\nOne column to be used in lexicographical sort\nOptions that define the sort order of a given column\nSet this sort options to sort in ascending order\nWhether <code>arrow_ord::rank</code> can rank an array of given data …\nWhether <code>sort_to_indices</code> can sort an array of given data …\nComputes the rank for a set of child values\nlexicographically compare values at the wrapped columns …\nSet this sort options to sort in descending order\nWhether to sort in descending order\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSort a list of <code>ArrayRef</code> using <code>SortOptions</code> provided for …\nSort elements lexicographically from a list of <code>ArrayRef</code> …\nCreate a new <code>SortOptions</code> struct\nSet this sort options to sort nulls first\nWhether to sort nulls first\nSet this sort options to sort nulls last\nSort options for this column\nIt’s unstable_sort, may not preserve the order of equal …\nSort the <code>ArrayRef</code> using <code>SortOptions</code>.\nSort the <code>ArrayRef</code> partially.\nSort elements from <code>ArrayRef</code> into an unsigned integer (…\nwe can only do this if the T is primitive\nCreate a new lex comparator that will wrap the given sort …\nThe column to sort\nSet this sort options to sort descending if argument is …\nSet this sort options to sort nulls first if argument is …")