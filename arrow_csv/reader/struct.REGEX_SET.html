<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Order should match `InferredDataType`"><title>REGEX_SET in arrow_csv::reader - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-198729e5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="arrow_csv" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.0-nightly (3f1be1ec7 2024-10-28)" data-channel="nightly" data-search-js="search-c5a66128.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../arrow_csv/index.html">arrow_<wbr>csv</a><span class="version">53.2.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">REGEX_<wbr>SET</a></h2><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.__private_field" title="__private_field">__private_field</a></li></ul><h3><a href="#deref-methods-RegexSet">Methods from Deref&lt;<wbr>Target=<wbr>Regex<wbr>Set&gt;</a></h3><ul class="block deref-methods"><li><a href="#method.is_empty" title="is_empty">is_empty</a></li><li><a href="#method.is_match" title="is_match">is_match</a></li><li><a href="#method.is_match_at" title="is_match_at">is_match_at</a></li><li><a href="#method.len" title="len">len</a></li><li><a href="#method.matches" title="matches">matches</a></li><li><a href="#method.matches_at" title="matches_at">matches_at</a></li><li><a href="#method.patterns" title="patterns">patterns</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-__Deref-for-REGEX_SET" title="Deref">Deref</a></li><li><a href="#impl-LazyStatic-for-REGEX_SET" title="LazyStatic">LazyStatic</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-REGEX_SET" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-REGEX_SET" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-REGEX_SET" title="Send">Send</a></li><li><a href="#impl-Sync-for-REGEX_SET" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-REGEX_SET" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-REGEX_SET" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Allocation-for-T" title="Allocation">Allocation</a></li><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In arrow_<wbr>csv::<wbr>reader</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">arrow_csv</a>::<wbr><a href="index.html">reader</a></span><h1>Struct <span class="struct">REGEX_SET</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/arrow_csv/reader/mod.rs.html#146-158">Source</a> </span></div><pre class="rust item-decl"><code>struct REGEX_SET {
    __private_field: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Order should match <a href="struct.InferredDataType.html" title="struct arrow_csv::reader::InferredDataType"><code>InferredDataType</code></a></p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.__private_field" class="structfield section-header"><a href="#structfield.__private_field" class="anchor field">§</a><code>__private_field: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a></code></span><details class="toggle big-toggle" open><summary><h2 id="deref-methods-RegexSet" class="section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = RegexSet&gt;</span><a href="#deref-methods-RegexSet" class="anchor">§</a></h2></summary><div id="deref-methods-RegexSet-1" class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_match" class="method"><h4 class="code-header">pub fn <a href="#method.is_match" class="fn">is_match</a>(&amp;self, haystack: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if one of the regexes in this set matches
the haystack given.</p>
<p>This method should be preferred if you only need to test whether any
of the regexes in the set should match, but don’t care about <em>which</em>
regexes matched. This is because the underlying matching engine will
quit immediately after seeing the first match instead of continuing to
find all matches.</p>
<p>Note that as with searches using <a href="crate::Regex"><code>Regex</code></a>, the
expression is unanchored by default. That is, if the regex does not
start with <code>^</code> or <code>\A</code>, or end with <code>$</code> or <code>\z</code>, then it is permitted
to match anywhere in the haystack.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<p>Tests whether a set matches somewhere in a haystack:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexSet;

<span class="kw">let </span>set = RegexSet::new([<span class="string">r"\w+"</span>, <span class="string">r"\d+"</span>]).unwrap();
<span class="macro">assert!</span>(set.is_match(<span class="string">"foo"</span>));
<span class="macro">assert!</span>(!set.is_match(<span class="string">"☃"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_match_at" class="method"><h4 class="code-header">pub fn <a href="#method.is_match_at" class="fn">is_match_at</a>(&amp;self, haystack: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if one of the regexes in this set matches the
haystack given, with the search starting at the offset given.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This panics when <code>start &gt;= haystack.len() + 1</code>.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>This example shows the significance of <code>start</code>. Namely, consider a
haystack <code>foobar</code> and a desire to execute a search starting at offset
<code>3</code>. You could search a substring explicitly, but then the look-around
assertions won’t work correctly. Instead, you can use this method to
specify the start position of a search.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexSet;

<span class="kw">let </span>set = RegexSet::new([<span class="string">r"\bbar\b"</span>, <span class="string">r"(?m)^bar$"</span>]).unwrap();
<span class="kw">let </span>hay = <span class="string">"foobar"</span>;
<span class="comment">// We get a match here, but it's probably not intended.
</span><span class="macro">assert!</span>(set.is_match(<span class="kw-2">&amp;</span>hay[<span class="number">3</span>..]));
<span class="comment">// No match because the  assertions take the context into account.
</span><span class="macro">assert!</span>(!set.is_match_at(hay, <span class="number">3</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.matches" class="method"><h4 class="code-header">pub fn <a href="#method.matches" class="fn">matches</a>(&amp;self, haystack: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; SetMatches</h4></section></summary><div class="docblock"><p>Returns the set of regexes that match in the given haystack.</p>
<p>The set returned contains the index of each regex that matches in
the given haystack. The index is in correspondence with the order of
regular expressions given to <code>RegexSet</code>’s constructor.</p>
<p>The set can also be used to iterate over the matched indices. The order
of iteration is always ascending with respect to the matching indices.</p>
<p>Note that as with searches using <a href="crate::Regex"><code>Regex</code></a>, the
expression is unanchored by default. That is, if the regex does not
start with <code>^</code> or <code>\A</code>, or end with <code>$</code> or <code>\z</code>, then it is permitted
to match anywhere in the haystack.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<p>Tests which regular expressions match the given haystack:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexSet;

<span class="kw">let </span>set = RegexSet::new([
    <span class="string">r"\w+"</span>,
    <span class="string">r"\d+"</span>,
    <span class="string">r"\pL+"</span>,
    <span class="string">r"foo"</span>,
    <span class="string">r"bar"</span>,
    <span class="string">r"barfoo"</span>,
    <span class="string">r"foobar"</span>,
]).unwrap();
<span class="kw">let </span>matches: Vec&lt;<span class="kw">_</span>&gt; = set.matches(<span class="string">"foobar"</span>).into_iter().collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]);

<span class="comment">// You can also test whether a particular regex matched:
</span><span class="kw">let </span>matches = set.matches(<span class="string">"foobar"</span>);
<span class="macro">assert!</span>(!matches.matched(<span class="number">5</span>));
<span class="macro">assert!</span>(matches.matched(<span class="number">6</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.matches_at" class="method"><h4 class="code-header">pub fn <a href="#method.matches_at" class="fn">matches_at</a>(&amp;self, haystack: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; SetMatches</h4></section></summary><div class="docblock"><p>Returns the set of regexes that match in the given haystack.</p>
<p>The set returned contains the index of each regex that matches in
the given haystack. The index is in correspondence with the order of
regular expressions given to <code>RegexSet</code>’s constructor.</p>
<p>The set can also be used to iterate over the matched indices. The order
of iteration is always ascending with respect to the matching indices.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>This panics when <code>start &gt;= haystack.len() + 1</code>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>Tests which regular expressions match the given haystack:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexSet;

<span class="kw">let </span>set = RegexSet::new([<span class="string">r"\bbar\b"</span>, <span class="string">r"(?m)^bar$"</span>]).unwrap();
<span class="kw">let </span>hay = <span class="string">"foobar"</span>;
<span class="comment">// We get matches here, but it's probably not intended.
</span><span class="kw">let </span>matches: Vec&lt;<span class="kw">_</span>&gt; = set.matches(<span class="kw-2">&amp;</span>hay[<span class="number">3</span>..]).into_iter().collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">// No matches because the  assertions take the context into account.
</span><span class="kw">let </span>matches: Vec&lt;<span class="kw">_</span>&gt; = set.matches_at(hay, <span class="number">3</span>).into_iter().collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of regexes in this set.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexSet;

<span class="macro">assert_eq!</span>(<span class="number">0</span>, RegexSet::empty().len());
<span class="macro">assert_eq!</span>(<span class="number">1</span>, RegexSet::new([<span class="string">r"[0-9]"</span>]).unwrap().len());
<span class="macro">assert_eq!</span>(<span class="number">2</span>, RegexSet::new([<span class="string">r"[0-9]"</span>, <span class="string">r"[a-z]"</span>]).unwrap().len());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if this set contains no regexes.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexSet;

<span class="macro">assert!</span>(RegexSet::empty().is_empty());
<span class="macro">assert!</span>(!RegexSet::new([<span class="string">r"[0-9]"</span>]).unwrap().is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.patterns" class="method"><h4 class="code-header">pub fn <a href="#method.patterns" class="fn">patterns</a>(&amp;self) -&gt; &amp;[<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>]</h4></section></summary><div class="docblock"><p>Returns the regex patterns that this regex set was constructed from.</p>
<p>This function can be used to determine the pattern for a match. The
slice returned has exactly as many patterns givens to this regex set,
and the order of the slice is the same as the order of the patterns
provided to the set.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::RegexSet;

<span class="kw">let </span>set = RegexSet::new(<span class="kw-2">&amp;</span>[
    <span class="string">r"\w+"</span>,
    <span class="string">r"\d+"</span>,
    <span class="string">r"\pL+"</span>,
    <span class="string">r"foo"</span>,
    <span class="string">r"bar"</span>,
    <span class="string">r"barfoo"</span>,
    <span class="string">r"foobar"</span>,
]).unwrap();
<span class="kw">let </span>matches: Vec&lt;<span class="kw">_</span>&gt; = set
    .matches(<span class="string">"foobar"</span>)
    .into_iter()
    .map(|index| <span class="kw-2">&amp;</span>set.patterns()[index])
    .collect();
<span class="macro">assert_eq!</span>(matches, <span class="macro">vec!</span>[<span class="string">r"\w+"</span>, <span class="string">r"\pL+"</span>, <span class="string">r"foo"</span>, <span class="string">r"bar"</span>, <span class="string">r"foobar"</span>]);</code></pre></div>
</div></details></div></details><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-__Deref-for-REGEX_SET" class="impl"><a class="src rightside" href="../../src/arrow_csv/reader/mod.rs.html#146-158">Source</a><a href="#impl-__Deref-for-REGEX_SET" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.REGEX_SET.html" title="struct arrow_csv::reader::REGEX_SET">REGEX_SET</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a class="src rightside" href="../../src/arrow_csv/reader/mod.rs.html#146-158">Source</a><a href="#associatedtype.Target" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = RegexSet</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="../../src/arrow_csv/reader/mod.rs.html#146-158">Source</a><a href="#method.deref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;RegexSet</h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><section id="impl-LazyStatic-for-REGEX_SET" class="impl"><a class="src rightside" href="../../src/arrow_csv/reader/mod.rs.html#146-158">Source</a><a href="#impl-LazyStatic-for-REGEX_SET" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://docs.rs/lazy_static/1.5.0/lazy_static/trait.LazyStatic.html" title="trait lazy_static::LazyStatic">LazyStatic</a> for <a class="struct" href="struct.REGEX_SET.html" title="struct arrow_csv::reader::REGEX_SET">REGEX_SET</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-REGEX_SET" class="impl"><a href="#impl-Freeze-for-REGEX_SET" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.REGEX_SET.html" title="struct arrow_csv::reader::REGEX_SET">REGEX_SET</a></h3></section><section id="impl-RefUnwindSafe-for-REGEX_SET" class="impl"><a href="#impl-RefUnwindSafe-for-REGEX_SET" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.REGEX_SET.html" title="struct arrow_csv::reader::REGEX_SET">REGEX_SET</a></h3></section><section id="impl-Send-for-REGEX_SET" class="impl"><a href="#impl-Send-for-REGEX_SET" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.REGEX_SET.html" title="struct arrow_csv::reader::REGEX_SET">REGEX_SET</a></h3></section><section id="impl-Sync-for-REGEX_SET" class="impl"><a href="#impl-Sync-for-REGEX_SET" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.REGEX_SET.html" title="struct arrow_csv::reader::REGEX_SET">REGEX_SET</a></h3></section><section id="impl-Unpin-for-REGEX_SET" class="impl"><a href="#impl-Unpin-for-REGEX_SET" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.REGEX_SET.html" title="struct arrow_csv::reader::REGEX_SET">REGEX_SET</a></h3></section><section id="impl-UnwindSafe-for-REGEX_SET" class="impl"><a href="#impl-UnwindSafe-for-REGEX_SET" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.REGEX_SET.html" title="struct arrow_csv::reader::REGEX_SET">REGEX_SET</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#765">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#768">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#748-750">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#758">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#805-807">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#809">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#812">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#790-792">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#794">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#797">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-Allocation-for-T" class="impl"><a href="#impl-Allocation-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Allocation for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section></div></section></div></main></body></html>